# JointProcessDpWorker - Документация

## Назначение

`JointProcessDpWorker` - центральный компонент системы, управляющий процессом навинчивания муфты. Реализует машину состояний для взаимодействия с ПЛК через OPC UA и координирует сбор данных в реальном времени.

**Расположение**: `PNTZ.Mufta.TPCApp\DpConnect\JointProcessDpWorker.cs`

## Протокол обмена с ПЛК

Операция навинчивания выполняется через последовательность команд:

1. **ПЛК → 10** (Труба появилась) → **TPC → 20** (Подтверждение)
2. **ПЛК → 30/25/28** (Готовность к навинчиванию/развинчиванию или ошибка преднавёртки)
3. **TPC → 38** (Начать запись параметров) → Сбор точек TqTnLenPoint → **ПЛК → 40** (Завершено)
4. **TPC → 45** (Ожидание оценки) → Автооценка или запрос оператора → **TPC → 50** (Оценка отправлена)
5. **ПЛК → 0** (Сброс, готов к новой операции)

При ошибке преднавёртки (команда 28) процедура завершается без записи параметров с ResultTotal = 2.

## События жизненного цикла

События вызываются последовательно в процессе навинчивания:

- `PipeAppear` - труба появилась на позиции (создаётся JointResult)
- `RecordingBegun` - началась запись параметров
- `NewTqTnLenPoint` - новая точка данных (вызывается многократно во время записи)
- `RecordingFinished` - запись завершена, данные собраны
- `AwaitForEvaluation` - требуется оценка оператора (если автооценка определила брак)
- `JointFinished` - операция полностью завершена, результат готов к сохранению

## Ключевые особенности

**Циклический режим**: Свойство `CyclicallyListen` управляет автоматическим перезапуском - после завершения операции автоматически ожидается следующая труба.

**Устойчивость к разрывам**: При потере связи с ПЛК прослушивание останавливается и автоматически возобновляется при восстановлении. Если операция уже началась, она завершится по таймауту.

**Компенсация смещения длины**: При начале записи запоминается начальная позиция головки (LengthOffset). Все точки данных корректируются относительно этой позиции с добавлением длины преднавёртки (MVS_Len).

**Таймауты**: CommandAwaitTimeout (60 сек) для ожидания команд от ПЛК, RecordingTimeout настраивается из рецепта (параметр MU_Moni_Time). Фактический таймаут записи параметров - 300 секунд.

**Автоматическая оценка**: Используется класс `JointEvaluation` для проверки результата. Если определён брак, запрашивается подтверждение оператора через событие AwaitForEvaluation.

## Интеграция

ViewModel подписывается на события для обновления UI и сохранения результатов. DpValues привязываются к OPC UA тегам через конфигурацию в DpConfig.xml. Класс регистрируется в IoC контейнере как Singleton.

## Проблемы 

1. Утечка подписок на события (Memory Leak)

В цикле ожидания команды 10 (строки 294-335) каждую итерацию создаётся новая подписка:
awaitCommandFeedback = new TaskCompletionSource<uint>();
DpPlcCommand.ValueUpdated += (s, v) => awaitCommandFeedback.TrySetResult(v);
Подписка никогда не отписывается. Если ПЛК будет слать команду 0 долго, накопятся сотни подписок. 
Это объясняет комментарий про "множественные подписки" в строке 328.

То же самое происходит на строках 345, 406, 492 - подписки добавляются, но не удаляются.

2. Блокировка потока в асинхронном методе

Строка 313:
Task.Delay(500).Wait();
Это блокирующий вызов в async методе - правильно было бы await Task.Delay(500). Блокирует поток пула и может привести к deadlock.

3. Race condition при отмене

При отмене через cts.Cancel() (строка 270) есть окно между проверкой first == tcs.Task и следующей операцией. 
Если отмена произойдёт между проверками, можно попытаться записать в уже отменённую операцию.

4. Неочищенный LengthOffset

LengthOffset обнуляется только в конце успешной операции (строка 511). 
Если операция прервётся по исключению или ошибке преднавёртки, offset останется и испортит следующую операцию.

5. Отсутствие отписки от NewTqTnLenPoint при исключениях

В RecordOperationParams (строка 519) подписка на NewTqTnLenPoint происходит до try-блока. 
Если исключение произойдёт ДО входа в Task.Delay (строка 524), отписка в catch не выполнится - утечка обработчика.

6. Множественные подписки на StatusChanged

При повторных подключениях/отключениях могут накапливаться подписки на DpPlcCommand.StatusChanged (строки 144, 161, 195), если не отписались корректно.

7. Нет обработки частичных данных

Если запись прервётся по таймауту, jointResult.Series будет содержать частичные данные, но это не отражено в метаданных результата. 
Невозможно понять, полные данные или обрезанные.

8. Потенциальная гонка с actualRecipe

actualRecipe устанавливается извне через SetActualRecipe() без блокировки. 
Если рецепт изменится во время выполнения операции, jointResult создаётся с одним рецептом, а timeout берётся из другого.

9. Задержки блокируют всё

Задержки 500ms разбросаны по коду (строки 313, 442, 484) и выполняются синхронно. 
Это добавляет ~1.5 секунды к каждой операции без явной необходимости.

10. Нет валидации состояния при старте

StartProcedureAsync проверяет только JointProcedureStarted, но не проверяет:
- Установлен ли actualRecipe
- Подключены ли все DpValues
- Валидны ли настройки

Самая критичная проблема

Утечка подписок на ValueUpdated - это потенциально катастрофично для долго работающего приложения. 
После нескольких часов работы могут быть тысячи "мёртвых" обработчиков, что приведёт к замедлению и утечке памяти.