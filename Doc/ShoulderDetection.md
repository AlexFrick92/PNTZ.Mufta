# Обнаружение точки контакта с заплечником (буртиком)

**Дата создания**: 2025-12-01
**Статус**: В обсуждении

---

## Контекст

При навертке муфты на трубу в режиме **TorqueShoulder** (контроль момента с заплечником), муфта свинчивается до момента контакта с буртиком трубы. В момент контакта момент затяжки резко возрастает, что является критической точкой процесса.

**Текущая ситуация**:
- Во время навертки собираются данные в виде массива точек `TqTnLenPoint[]`
- Данные сохраняются в `JointResult` (поле `TqTnLenPoints` - сериализованный массив)
- Точка контакта с заплечником в данный момент **не определяется автоматически**

**Зачем нужно**:
- Автоматическая оценка качества свинчивания
- Визуализация критической точки на графике
- Валидация результата операции
- Аналитика и отчетность

---

## Постановка задачи

**Цель**: Разработать алгоритм автоматического определения точки контакта муфты с заплечником трубы по анализу графика зависимости момента от длины/оборотов.

**Критерий успеха**: Алгоритм находит точку, в которой момент начинает резко возрастать (контакт с буртиком).

---

## Исходные данные

### Структура данных точки
```csharp
public class TqTnLenPoint
{
    public float Torque;           // Момент затяжки (Нм)
    public float Length;           // Длина свинчивания (м)
    public float Turns;            // Количество оборотов
    public float TurnsPerMinute;   // Скорость вращения (об/мин)
    public int TimeStamp;          // Время от начала записи (мс)
}
```

### Где хранятся данные
- **Во время процесса**: Генерируются в `JointProcessDpWorker` через событие `NewTqTnLenPoint`
- **После завершения**: Сериализованы в `JointResult.TqTnLenPoints` (строка)
- **База данных**: `JointResultTable` в локальной SQLite и удаленной PostgreSQL

### Характер данных
- Данные содержат **шум** (уже применяется `MovingAverage(3)` для момента в `JointProcessDpWorker.cs:48`)
- До контакта с заплечником: момент растет **медленно/плавно**
- После контакта: момент растет **резко/быстро**
- Точка перехода и есть искомая точка контакта

---

## Требования

### Функциональные
- [ ] Алгоритм должен работать с массивом `TqTnLenPoint[]`
- [ ] Возвращать индекс точки контакта или `null` если не найдена
- [ ] Устойчивость к шуму в данных
- [ ] Настраиваемые пороговые значения

### Нефункциональные
- [ ] Производительность: обработка в реальном времени или постобработка?
- [ ] Надежность: минимизация ложных срабатываний
- [ ] Переиспользование: возможность применения для других режимов?

### Вопросы для уточнения
- [ ] Нужно ли определять точку в **реальном времени** (во время навертки) или **после** завершения?
- [ ] Какие типичные значения моментов до и после контакта? (для настройки порогов)
- [ ] Есть ли примеры реальных данных для тестирования?
- [ ] Нужна ли визуализация найденной точки на графике?
- [ ] Должна ли точка сохраняться в `JointResult`?

---

## Предложенные решения

### Вариант 1: Анализ первой производной (dTorque/dLength)
**Идея**: Найти точку, где скорость изменения момента максимальна или превышает порог.

```
1. Вычислить производную момента: derivative[i] = (Torque[i] - Torque[i-1]) / (Length[i] - Length[i-1])
2. Применить сглаживание (MovingAverage)
3. Найти точку максимума или превышения порога
```

**Плюсы**:
- Простота реализации
- Хорошо работает при явном изменении тренда

**Минусы**:
- Чувствительность к выбросам без сглаживания

---

### Вариант 2: Анализ второй производной (d²Torque/dLength²)
**Идея**: Найти точку максимального ускорения роста момента.

```
1. Первая производная: dTorque/dLength
2. Вторая производная: d²Torque/dLength²
3. Найти максимум второй производной
```

**Плюсы**:
- Точнее определяет начало резкого изменения

**Минусы**:
- Усиливает шум, требует хорошего сглаживания

---

### Вариант 3: Скользящее окно с анализом тренда
**Идея**: Сравнивать средний наклон до и после каждой точки.

```
Для каждой точки i:
  slopeBefore = среднее(derivative[i-N...i])
  slopeAfter = среднее(derivative[i...i+N])
  ratio[i] = slopeAfter / slopeBefore

Найти точку с максимальным ratio
```

**Плюсы**:
- Устойчивость к выбросам
- Хорошо работает на зашумленных данных

**Минусы**:
- Требует подбора размера окна N

---

### Вариант 4: Комбинированный с пороговыми значениями
**Идея**: Использовать несколько критериев одновременно.

```
Критерии:
- Момент > MinTorqueThreshold (отсечь начальный шум)
- Производная > DerivativeThreshold
- Длина/обороты в допустимом диапазоне
```

**Плюсы**:
- Наиболее надежный
- Гибкая настройка

**Минусы**:
- Больше параметров для настройки

---

## Архитектурное решение

### Где разместить код?
**Вариант A**: Новый класс `Domain/ShoulderContactDetector.cs`
**Вариант B**: Методы в `Domain/JointEvaluation.cs`
**Вариант C**: Утилита в `Toolbox/Analysis/`

### Интеграция
- `JointProcessViewModel` - визуализация в реальном времени
- `JointEvaluation` - автоматическая валидация
- `ResultsViewModel` - анализ исторических данных

---

## Решение (выбранное)

_Заполнится после обсуждения_

---

## План реализации

_Заполнится после выбора решения_

1. [ ] Создать класс детектора
2. [ ] Реализовать алгоритм
3. [ ] Добавить юнит-тесты
4. [ ] Интегрировать в ViewModel
5. [ ] Визуализация на графике
6. [ ] Сохранение точки в результат

---

## Тестирование

### Тестовые данные
_Требуется предоставить примеры реальных данных_

### Критерии качества
- Точность определения: ±X точек от реальной точки контакта
- Процент ложных срабатываний: < Y%
- Процент пропусков: < Z%

---

## Замечания и вопросы

- Какая частота дискретизации данных (как часто приходят точки)?
- Есть ли случаи, когда контакт не должен быть найден (аварийные ситуации)?
- Нужно ли логирование результатов работы детектора?

---

## История изменений

- **2025-12-01**: Создание документа, первичная формулировка задачи
